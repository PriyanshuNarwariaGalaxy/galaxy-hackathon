{
  "version": 3,
  "sources": ["../../../src/core/nodes/registry.ts", "../../../src/core/nodes/definitions/image.node.ts", "../../../src/core/nodes/base.ts", "../../../src/core/nodes/definitions/llm.node.ts", "../../../src/core/nodes/definitions/prompt.node.ts"],
  "sourcesContent": ["import { z } from \"zod\";\nimport type { AnyNodeDefinition, NodeInput, NodeOutput } from \"./types\";\nimport { imageNode } from \"./definitions/image.node\";\nimport { llmNode } from \"./definitions/llm.node\";\nimport { promptNode } from \"./definitions/prompt.node\";\n\n/**\n * The single source of truth for which nodes exist in the system.\n *\n * Why an object (instead of scattered exports)?\n * - Makes node types derivable (NodeType = keyof typeof nodeDefinitions)\n * - Makes runtime enumeration trivial (for validation + UI later)\n * - Encourages explicit registration, which is critical in production systems\n */\nexport const nodeDefinitions = {\n  prompt: promptNode,\n  image: imageNode,\n  llm: llmNode,\n} as const;\n\nexport type NodeType = keyof typeof nodeDefinitions;\nexport type RegisteredNodeDefinition<TType extends NodeType = NodeType> =\n  (typeof nodeDefinitions)[TType];\n\nfunction nonEmptyArray<T>(arr: T[]): [T, ...T[]] {\n  if (arr.length === 0) {\n    // This should never happen (we ship with built-in node defs),\n    // but it protects the contract for `z.enum(...)`.\n    throw new Error(\"Node registry must include at least one node definition.\");\n  }\n  return arr as [T, ...T[]];\n}\n\n/**\n * Runtime schema for node type.\n * Derived from `nodeDefinitions` so we don't duplicate identifiers.\n */\nexport const nodeTypeSchema = z.enum(\n  nonEmptyArray(Object.keys(nodeDefinitions) as NodeType[]),\n);\n\n/**\n * NodeRegistry is a thin type-safe wrapper around the registered definitions.\n *\n * Why does this abstraction exist?\n * - Centralizes node lookup (and later: node versioning, deprecation, etc.)\n * - Provides canonical parsing helpers (input/output validation via Zod)\n * - Ensures the map remains type-safe and extensible\n */\nexport class NodeRegistry<TDefs extends Record<string, AnyNodeDefinition>> {\n  public readonly definitions: TDefs;\n\n  constructor(definitions: TDefs) {\n    this.definitions = definitions;\n  }\n\n  listTypes(): Array<keyof TDefs> {\n    return Object.keys(this.definitions) as Array<keyof TDefs>;\n  }\n\n  get<TType extends keyof TDefs>(type: TType): TDefs[TType] {\n    const def = this.definitions[type];\n    if (!def) {\n      // Defensive: should be impossible in typed code, but workflows are data.\n      throw new Error(`Unknown node type: ${String(type)}`);\n    }\n    return def;\n  }\n\n  parseInput<TType extends keyof TDefs>(\n    type: TType,\n    input: unknown,\n  ): NodeInput<TDefs[TType]> {\n    return this.get(type).inputSchema.parse(input) as NodeInput<TDefs[TType]>;\n  }\n\n  parseOutput<TType extends keyof TDefs>(\n    type: TType,\n    output: unknown,\n  ): NodeOutput<TDefs[TType]> {\n    return this.get(type).outputSchema.parse(output) as NodeOutput<TDefs[TType]>;\n  }\n}\n\nexport const nodeRegistry = new NodeRegistry(nodeDefinitions);\n\n", "import { z } from \"zod\";\nimport { defineNode } from \"../base\";\n\n/**\n * Image Node\n * - Pure contract: passes through image payload (base64 + mimeType).\n */\nexport const imageNode = defineNode({\n  type: \"image\",\n  title: \"Image\",\n  description: \"Represents an image payload used as a workflow input or intermediate artifact.\",\n  inputSchema: z.object({\n    imageBase64: z.string(),\n    mimeType: z.string(),\n  }),\n  outputSchema: z.object({\n    imageBase64: z.string(),\n    mimeType: z.string(),\n  }),\n} as const);\n\n", "import type { z } from \"zod\";\nimport type { AnyNodeDefinition, NodeDefinition, ZodAny } from \"./types\";\n\n/**\n * `defineNode` exists to make node definitions:\n * - consistent (one canonical shape)\n * - strongly typed (schemas drive the inferred input/output types)\n * - future-proof (we can add metadata fields without changing all callsites)\n *\n * There is deliberately NO runtime behavior here beyond returning the object.\n */\nexport function defineNode<\n  const TType extends string,\n  TInputSchema extends ZodAny,\n  TOutputSchema extends ZodAny,\n>(definition: NodeDefinition<TType, TInputSchema, TOutputSchema>) {\n  return definition;\n}\n\nexport type NodeInputOf<TNode extends AnyNodeDefinition> = z.infer<TNode[\"inputSchema\"]>;\nexport type NodeOutputOf<TNode extends AnyNodeDefinition> = z.infer<TNode[\"outputSchema\"]>;\n\n", "import { z } from \"zod\";\nimport { defineNode } from \"../base\";\n\n/**\n * LLM Node\n * - Pure contract: declares prompt + optional images + config.\n * - Providers list is constrained to known provider identifiers (for future execution).\n */\nexport const llmNode = defineNode({\n  type: \"llm\",\n  title: \"LLM\",\n  description: \"Requests an LLM completion with optional images and provider selection constraints.\",\n  inputSchema: z.object({\n    prompt: z.string(),\n    images: z\n      .array(\n        z.object({\n          imageBase64: z.string(),\n          mimeType: z.string(),\n        }),\n      )\n      .optional(),\n    config: z.object({\n      model: z.string(),\n      temperature: z.number(),\n      providers: z.array(z.enum([\"fal\", \"replicate\", \"wavespeed\"])),\n    }),\n  }),\n  outputSchema: z.object({\n    text: z.string(),\n    providerUsed: z.string(),\n  }),\n} as const);\n\n", "import { z } from \"zod\";\nimport { defineNode } from \"../base\";\n\n/**\n * Prompt Node\n * - Pure contract: takes text, returns text.\n */\nexport const promptNode = defineNode({\n  type: \"prompt\",\n  title: \"Prompt\",\n  description: \"Represents raw user text used as a prompt input.\",\n  inputSchema: z.object({\n    text: z.string(),\n  }),\n  outputSchema: z.object({\n    text: z.string(),\n  }),\n} as const);\n\n"],
  "mappings": ";;;;;;;;;AAAA;;;ACAA;;;ACAA;AAWO,SAAS,WAId,YAAgE;AAChE,SAAO;AACT;AANgB;;;ADJT,IAAM,YAAY,WAAW;AAAA,EAClC,MAAM;AAAA,EACN,OAAO;AAAA,EACP,aAAa;AAAA,EACb,aAAa,iBAAE,OAAO;AAAA,IACpB,aAAa,iBAAE,OAAO;AAAA,IACtB,UAAU,iBAAE,OAAO;AAAA,EACrB,CAAC;AAAA,EACD,cAAc,iBAAE,OAAO;AAAA,IACrB,aAAa,iBAAE,OAAO;AAAA,IACtB,UAAU,iBAAE,OAAO;AAAA,EACrB,CAAC;AACH,CAAU;;;AEnBV;AAQO,IAAM,UAAU,WAAW;AAAA,EAChC,MAAM;AAAA,EACN,OAAO;AAAA,EACP,aAAa;AAAA,EACb,aAAa,iBAAE,OAAO;AAAA,IACpB,QAAQ,iBAAE,OAAO;AAAA,IACjB,QAAQ,iBACL;AAAA,MACC,iBAAE,OAAO;AAAA,QACP,aAAa,iBAAE,OAAO;AAAA,QACtB,UAAU,iBAAE,OAAO;AAAA,MACrB,CAAC;AAAA,IACH,EACC,SAAS;AAAA,IACZ,QAAQ,iBAAE,OAAO;AAAA,MACf,OAAO,iBAAE,OAAO;AAAA,MAChB,aAAa,iBAAE,OAAO;AAAA,MACtB,WAAW,iBAAE,MAAM,iBAAE,KAAK,CAAC,OAAO,aAAa,WAAW,CAAC,CAAC;AAAA,IAC9D,CAAC;AAAA,EACH,CAAC;AAAA,EACD,cAAc,iBAAE,OAAO;AAAA,IACrB,MAAM,iBAAE,OAAO;AAAA,IACf,cAAc,iBAAE,OAAO;AAAA,EACzB,CAAC;AACH,CAAU;;;AChCV;AAOO,IAAM,aAAa,WAAW;AAAA,EACnC,MAAM;AAAA,EACN,OAAO;AAAA,EACP,aAAa;AAAA,EACb,aAAa,iBAAE,OAAO;AAAA,IACpB,MAAM,iBAAE,OAAO;AAAA,EACjB,CAAC;AAAA,EACD,cAAc,iBAAE,OAAO;AAAA,IACrB,MAAM,iBAAE,OAAO;AAAA,EACjB,CAAC;AACH,CAAU;;;AJHH,IAAM,kBAAkB;AAAA,EAC7B,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,KAAK;AACP;AAMA,SAAS,cAAiB,KAAuB;AAC/C,MAAI,IAAI,WAAW,GAAG;AAGpB,UAAM,IAAI,MAAM,0DAA0D;AAAA,EAC5E;AACA,SAAO;AACT;AAPS;AAaF,IAAM,iBAAiB,iBAAE;AAAA,EAC9B,cAAc,OAAO,KAAK,eAAe,CAAe;AAC1D;AAUO,IAAM,eAAN,MAAoE;AAAA,EAjD3E,OAiD2E;AAAA;AAAA;AAAA,EAGzE,YAAY,aAAoB;AAC9B,SAAK,cAAc;AAAA,EACrB;AAAA,EAEA,YAAgC;AAC9B,WAAO,OAAO,KAAK,KAAK,WAAW;AAAA,EACrC;AAAA,EAEA,IAA+B,MAA2B;AACxD,UAAM,MAAM,KAAK,YAAY,IAAI;AACjC,QAAI,CAAC,KAAK;AAER,YAAM,IAAI,MAAM,sBAAsB,OAAO,IAAI,CAAC,EAAE;AAAA,IACtD;AACA,WAAO;AAAA,EACT;AAAA,EAEA,WACE,MACA,OACyB;AACzB,WAAO,KAAK,IAAI,IAAI,EAAE,YAAY,MAAM,KAAK;AAAA,EAC/C;AAAA,EAEA,YACE,MACA,QAC0B;AAC1B,WAAO,KAAK,IAAI,IAAI,EAAE,aAAa,MAAM,MAAM;AAAA,EACjD;AACF;AAEO,IAAM,eAAe,IAAI,aAAa,eAAe;",
  "names": []
}
