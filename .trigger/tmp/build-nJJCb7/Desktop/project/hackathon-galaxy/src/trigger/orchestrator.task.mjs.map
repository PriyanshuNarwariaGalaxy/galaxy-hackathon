{
  "version": 3,
  "sources": ["../../../../../../../../src/trigger/orchestrator.task.ts"],
  "sourcesContent": ["import { logger, task, tasks } from \"@trigger.dev/sdk/v3\";\n\nimport { workflowSchema } from \"../core/workflow/workflow.schema\";\nimport { topologicallySortNodeIds } from \"../core/workflow/dag\";\nimport { nodeRegistry } from \"../core/nodes/registry\";\n\nimport type { ExecutionContext, ExecutionRun, NodeExecutionResult } from \"./execution.types\";\nimport { nodeTask } from \"./node.task\";\n\n/**\n * Orchestrator task:\n * - validates workflow JSON (Phase 1 schema)\n * - topologically sorts nodes (Phase 1 DAG util)\n * - executes nodes sequentially in dependency order\n * - triggers each node via triggerAndWait (all work happens inside tasks)\n * - accumulates outputs in an execution context keyed by nodeId\n * - logs start/end + per-node details for debugging\n *\n * NOTE: \"Input wiring\" is intentionally minimal in Phase 2 because the\n * workflow schema does not yet describe port mappings. Today we treat the\n * node's `input` as the literal payload to validate/execute.\n * In a future phase, `buildNodeInput()` can resolve references from context.\n */\n\nexport const orchestratorTask = task({\n  id: \"workflow.orchestrator\",\n  run: async (payload: { workflow: unknown }, { ctx }) => {\n    logger.info(\"Workflow execution start\", {\n      task: \"workflow.orchestrator\",\n      runId: ctx.run.id,\n    });\n\n    const workflow = workflowSchema.parse(payload.workflow);\n\n    const executionOrder = topologicallySortNodeIds(workflow.nodes, workflow.edges);\n\n    const context: ExecutionContext = { outputsByNodeId: {} };\n    const nodeResults: NodeExecutionResult[] = [];\n    const startedAt = new Date().toISOString();\n\n    for (const nodeId of executionOrder) {\n      const node = workflow.nodes.find((n) => n.id === nodeId);\n      if (!node) {\n        // Defensive: topo-sort is built from these nodes, so this should never happen.\n        throw new Error(`Internal error: node \"${nodeId}\" not found in workflow.nodes`);\n      }\n\n      const nodeStartedAt = new Date().toISOString();\n      logger.info(\"Node orchestration start\", { nodeId, type: node.type, runId: ctx.run.id });\n\n      // \"Build input from context\" hook (currently passthrough).\n      const effectiveInput = buildNodeInput(nodeId, node.input, context);\n\n      // Validate the effective input early for better orchestrator-level errors.\n      // Node task will also validate (defense-in-depth).\n      nodeRegistry.parseInput(node.type, effectiveInput);\n\n      const result = await tasks.triggerAndWait<typeof nodeTask>(nodeTask.id, {\n        nodeId,\n        type: node.type,\n        input: effectiveInput,\n      });\n\n      if (!result.ok) {\n        logger.error(\"Node execution failed\", {\n          nodeId,\n          type: node.type,\n          error: result.error,\n          runId: ctx.run.id,\n        });\n        throw new Error(`Node \"${nodeId}\" (${node.type}) failed`);\n      }\n\n      context.outputsByNodeId[nodeId] = result.output;\n\n      const nodeFinishedAt = new Date().toISOString();\n      nodeResults.push({\n        nodeId,\n        type: node.type,\n        startedAt: nodeStartedAt,\n        finishedAt: nodeFinishedAt,\n        input: effectiveInput,\n        output: result.output,\n      });\n\n      logger.info(\"Node orchestration complete\", {\n        nodeId,\n        type: node.type,\n        output: result.output,\n        runId: ctx.run.id,\n      });\n    }\n\n    const finishedAt = new Date().toISOString();\n\n    const run: ExecutionRun = {\n      runId: ctx.run.id,\n      status: \"completed\",\n      startedAt,\n      finishedAt,\n      workflow,\n      executionOrder,\n      context,\n      nodeResults,\n    };\n\n    logger.info(\"Workflow execution complete\", {\n      runId: ctx.run.id,\n      nodeCount: workflow.nodes.length,\n      executionOrder,\n    });\n\n    return run;\n  },\n});\n\nfunction buildNodeInput(nodeId: string, rawInput: unknown, _ctx: ExecutionContext): unknown {\n  // Placeholder for future \"wiring\" support (references, port mappings, etc).\n  // Keeping this hook makes Phase 3+ changes localized and testable.\n  return rawInput;\n}\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAwBO,IAAM,mBAAmB,KAAK;AAAA,EACnC,IAAI;AAAA,EACJ,KAAK,8BAAO,SAAgC,EAAE,IAAI,MAAM;AACtD,WAAO,KAAK,4BAA4B;AAAA,MACtC,MAAM;AAAA,MACN,OAAO,IAAI,IAAI;AAAA,IACjB,CAAC;AAED,UAAM,WAAW,eAAe,MAAM,QAAQ,QAAQ;AAEtD,UAAM,iBAAiB,yBAAyB,SAAS,OAAO,SAAS,KAAK;AAE9E,UAAM,UAA4B,EAAE,iBAAiB,CAAC,EAAE;AACxD,UAAM,cAAqC,CAAC;AAC5C,UAAM,aAAY,oBAAI,KAAK,GAAE,YAAY;AAEzC,eAAW,UAAU,gBAAgB;AACnC,YAAM,OAAO,SAAS,MAAM,KAAK,CAAC,MAAM,EAAE,OAAO,MAAM;AACvD,UAAI,CAAC,MAAM;AAET,cAAM,IAAI,MAAM,yBAAyB,MAAM,+BAA+B;AAAA,MAChF;AAEA,YAAM,iBAAgB,oBAAI,KAAK,GAAE,YAAY;AAC7C,aAAO,KAAK,4BAA4B,EAAE,QAAQ,MAAM,KAAK,MAAM,OAAO,IAAI,IAAI,GAAG,CAAC;AAGtF,YAAM,iBAAiB,eAAe,QAAQ,KAAK,OAAO,OAAO;AAIjE,mBAAa,WAAW,KAAK,MAAM,cAAc;AAEjD,YAAM,SAAS,MAAM,MAAM,eAAgC,SAAS,IAAI;AAAA,QACtE;AAAA,QACA,MAAM,KAAK;AAAA,QACX,OAAO;AAAA,MACT,CAAC;AAED,UAAI,CAAC,OAAO,IAAI;AACd,eAAO,MAAM,yBAAyB;AAAA,UACpC;AAAA,UACA,MAAM,KAAK;AAAA,UACX,OAAO,OAAO;AAAA,UACd,OAAO,IAAI,IAAI;AAAA,QACjB,CAAC;AACD,cAAM,IAAI,MAAM,SAAS,MAAM,MAAM,KAAK,IAAI,UAAU;AAAA,MAC1D;AAEA,cAAQ,gBAAgB,MAAM,IAAI,OAAO;AAEzC,YAAM,kBAAiB,oBAAI,KAAK,GAAE,YAAY;AAC9C,kBAAY,KAAK;AAAA,QACf;AAAA,QACA,MAAM,KAAK;AAAA,QACX,WAAW;AAAA,QACX,YAAY;AAAA,QACZ,OAAO;AAAA,QACP,QAAQ,OAAO;AAAA,MACjB,CAAC;AAED,aAAO,KAAK,+BAA+B;AAAA,QACzC;AAAA,QACA,MAAM,KAAK;AAAA,QACX,QAAQ,OAAO;AAAA,QACf,OAAO,IAAI,IAAI;AAAA,MACjB,CAAC;AAAA,IACH;AAEA,UAAM,cAAa,oBAAI,KAAK,GAAE,YAAY;AAE1C,UAAM,MAAoB;AAAA,MACxB,OAAO,IAAI,IAAI;AAAA,MACf,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,WAAO,KAAK,+BAA+B;AAAA,MACzC,OAAO,IAAI,IAAI;AAAA,MACf,WAAW,SAAS,MAAM;AAAA,MAC1B;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT,GAvFK;AAwFP,CAAC;AAED,SAAS,eAAe,QAAgB,UAAmB,MAAiC;AAG1F,SAAO;AACT;AAJS;",
  "names": []
}
