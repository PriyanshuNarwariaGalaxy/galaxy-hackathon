{
  "version": 3,
  "sources": ["../../../../../../../../src/trigger/workflow-orchestrator.task.ts"],
  "sourcesContent": ["import { logger, task, tasks } from \"@trigger.dev/sdk/v3\";\nimport { z } from \"zod\";\n\nimport { workflowSchema } from \"@/src/core/workflow/workflow.schema\";\nimport { topologicallySortNodeIds } from \"@/src/core/workflow/dag\";\nimport { prisma } from \"@/src/db/prisma\";\n\nimport { promptTask } from \"@/src/trigger/tasks/prompt.task\";\nimport { imageTask } from \"@/src/trigger/tasks/image.task\";\nimport { llmTask } from \"@/src/trigger/tasks/llm.task\";\n\nconst payloadSchema = z.object({\n  workflowId: z.string().min(1),\n  workflowRunId: z.string().min(1),\n});\n\nfunction now() {\n  return new Date();\n}\n\nfunction getTaskIdForType(type: string) {\n  switch (type) {\n    case \"prompt\":\n      return promptTask.id;\n    case \"image\":\n      return imageTask.id;\n    case \"llm\":\n      return llmTask.id;\n    default:\n      throw new Error(`Unknown node type: ${type}`);\n  }\n}\n\n/**\n * Phase 3 Orchestrator:\n * - loads workflow from DB (React Flow nodes/edges)\n * - adapts to Phase 1 execution schema shape {id,type,input}\n * - validates with Phase 1 Zod schema\n * - topo-sorts and runs nodes sequentially via triggerAndWait\n * - persists WorkflowRun + NodeRun status, timings, context\n */\nexport const workflowOrchestratorTask = task({\n  id: \"workflow.orchestrator.v3\",\n  run: async (rawPayload: unknown, { ctx }) => {\n    const payload = payloadSchema.parse(rawPayload);\n\n    logger.info(\"Workflow run start\", {\n      workflowId: payload.workflowId,\n      workflowRunId: payload.workflowRunId,\n      triggerRunId: ctx.run.id,\n    });\n\n    await prisma.workflowRun.update({\n      where: { id: payload.workflowRunId },\n      data: { status: \"RUNNING\", startedAt: now(), triggerRunId: ctx.run.id },\n    });\n\n    const workflow = await prisma.workflow.findUnique({\n      where: { id: payload.workflowId },\n      select: { id: true, name: true, nodes: true, edges: true },\n    });\n    if (!workflow) {\n      await prisma.workflowRun.update({\n        where: { id: payload.workflowRunId },\n        data: { status: \"FAILED\", finishedAt: now(), error: \"Workflow not found\" },\n      });\n      throw new Error(\"Workflow not found\");\n    }\n\n    // Adapt persisted React Flow graph -> Phase 1 execution schema graph\n    const rfNodes = workflow.nodes as any[];\n    const rfEdges = workflow.edges as any[];\n\n    const execNodes = rfNodes.map((n) => ({\n      id: String(n.id),\n      type: String(n.type),\n      input: n?.data?.input ?? {},\n    }));\n    const execEdges = rfEdges.map((e) => ({\n      from: String(e.source),\n      to: String(e.target),\n    }));\n\n    // Validate structure + node types against Phase 1 contract registry\n    const validatedWorkflow = workflowSchema.parse({ nodes: execNodes, edges: execEdges });\n\n    const order = topologicallySortNodeIds(validatedWorkflow.nodes, validatedWorkflow.edges);\n\n    const context: Record<string, unknown> = {};\n\n    for (const nodeId of order) {\n      const current = await prisma.workflowRun.findUnique({\n        where: { id: payload.workflowRunId },\n        select: { status: true },\n      });\n      if (current?.status === \"CANCELED\") {\n        // Mark remaining queued nodes as canceled and stop scheduling new work.\n        await prisma.nodeRun.updateMany({\n          where: { workflowRunId: payload.workflowRunId, status: \"QUEUED\" },\n          data: { status: \"CANCELED\", finishedAt: now() },\n        });\n        await prisma.workflowRun.update({\n          where: { id: payload.workflowRunId },\n          data: { status: \"CANCELED\", finishedAt: now(), context: context as any },\n        });\n        logger.info(\"Workflow run canceled\", {\n          workflowId: payload.workflowId,\n          workflowRunId: payload.workflowRunId,\n          triggerRunId: ctx.run.id,\n        });\n        return { workflowRunId: payload.workflowRunId, status: \"CANCELED\" as const };\n      }\n\n      const node = validatedWorkflow.nodes.find((n) => n.id === nodeId)!;\n      const taskId = getTaskIdForType(node.type);\n\n      logger.info(\"Node start\", { workflowRunId: payload.workflowRunId, nodeId, type: node.type });\n\n      // Minimal context passing: allow nodes to reference previous outputs via \"$from\".\n      // If node.input contains { $from: \"someNodeId\" }, replace it with that node output.\n      const effectiveInput = resolveInput(node.input, context);\n\n      const result = await tasks.triggerAndWait(taskId as any, {\n        workflowRunId: payload.workflowRunId,\n        nodeId,\n        input: effectiveInput,\n      });\n\n      if (!result.ok) {\n        await prisma.nodeRun.update({\n          where: { workflowRunId_nodeId: { workflowRunId: payload.workflowRunId, nodeId } },\n          data: { status: \"FAILED\", finishedAt: now(), error: \"Node task failed\" },\n        });\n        await prisma.workflowRun.update({\n          where: { id: payload.workflowRunId },\n          data: { status: \"FAILED\", finishedAt: now(), error: `Node failed: ${nodeId}` },\n        });\n        throw new Error(`Node \"${nodeId}\" failed`);\n      }\n\n      // If the run was canceled while we were waiting for this node, ignore output and stop.\n      const after = await prisma.workflowRun.findUnique({\n        where: { id: payload.workflowRunId },\n        select: { status: true },\n      });\n      if (after?.status === \"CANCELED\") {\n        await prisma.nodeRun.updateMany({\n          where: { workflowRunId: payload.workflowRunId, status: \"QUEUED\" },\n          data: { status: \"CANCELED\", finishedAt: now() },\n        });\n        await prisma.workflowRun.update({\n          where: { id: payload.workflowRunId },\n          data: { status: \"CANCELED\", finishedAt: now(), context: context as any },\n        });\n        logger.info(\"Workflow run canceled (post-node)\", {\n          workflowId: payload.workflowId,\n          workflowRunId: payload.workflowRunId,\n          triggerRunId: ctx.run.id,\n        });\n        return { workflowRunId: payload.workflowRunId, status: \"CANCELED\" as const };\n      }\n\n      context[nodeId] = result.output;\n\n      logger.info(\"Node complete\", { workflowRunId: payload.workflowRunId, nodeId, type: node.type });\n    }\n\n    await prisma.workflowRun.update({\n      where: { id: payload.workflowRunId },\n      data: { status: \"COMPLETED\", finishedAt: now(), context: context as any },\n    });\n\n    logger.info(\"Workflow run complete\", {\n      workflowId: payload.workflowId,\n      workflowRunId: payload.workflowRunId,\n      triggerRunId: ctx.run.id,\n    });\n\n    return { workflowRunId: payload.workflowRunId, status: \"COMPLETED\" as const };\n  },\n});\n\nfunction resolveInput(input: unknown, context: Record<string, unknown>): unknown {\n  if (input && typeof input === \"object\" && !Array.isArray(input)) {\n    const anyObj = input as any;\n    if (typeof anyObj.$from === \"string\") {\n      return context[anyObj.$from] ?? {};\n    }\n  }\n  return input;\n}\n\n"],
  "mappings": "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",
  "names": []
}
