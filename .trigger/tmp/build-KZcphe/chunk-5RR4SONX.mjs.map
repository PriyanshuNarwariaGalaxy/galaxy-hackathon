{
  "version": 3,
  "sources": ["../../../src/trigger/node.task.ts"],
  "sourcesContent": ["import { logger, task } from \"@trigger.dev/sdk/v3\";\nimport { z } from \"zod\";\n\nimport { nodeRegistry, type NodeType } from \"../core/nodes/registry\";\n\n/**\n * Node task :\n * - Validates input with the node's Zod input schema\n * - Executes deterministic mock logic (no providers yet)\n * - Validates output with the node's Zod output schema\n *\n * IMPORTANT: This is the only place where node \"work\" happens.\n * The orchestrator does orchestration only.\n */\n\nexport const nodeTask = task({\n  id: \"workflow.node\",\n  run: async (\n    payload: {\n      nodeId: string;\n      type: NodeType;\n      input: unknown;\n    },\n    { ctx },\n  ) => {\n    logger.info(\"Node execution start\", {\n      nodeId: payload.nodeId,\n      type: payload.type,\n      runId: ctx.run.id,\n    });\n\n    const def = nodeRegistry.get(payload.type);\n\n    // Validate input at the boundary.\n    const validatedInput = def.inputSchema.parse(payload.input);\n\n    // Deterministic mock execution (must match the output schema).\n    const rawOutput: unknown = mockExecute(payload.type, validatedInput);\n\n    // Validate output at the boundary.\n    const validatedOutput = def.outputSchema.parse(rawOutput);\n\n    logger.info(\"Node execution complete\", {\n      nodeId: payload.nodeId,\n      type: payload.type,\n      output: validatedOutput,\n      runId: ctx.run.id,\n    });\n\n    return validatedOutput;\n  },\n});\n\nfunction mockExecute(type: NodeType, input: unknown): unknown {\n  switch (type) {\n    case \"prompt\": {\n      // Contract: { text: string } -> { text: string }\n      return { text: \"mock prompt output\" };\n    }\n    case \"image\": {\n      // Contract: { imageBase64: string, mimeType: string } -> same shape\n      return { imageBase64: \"mock-image-base64\", mimeType: \"image/png\" };\n    }\n    case \"llm\": {\n      // Contract: { prompt, images?, config } -> { text, providerUsed }\n      const parsed = z\n        .object({\n          config: z.object({\n            providers: z.array(z.string()),\n          }),\n        })\n        .safeParse(input);\n\n      const providerUsed = parsed.success ? parsed.data.config.providers[0] ?? \"mock\" : \"mock\";\n      return { text: \"mock LLM output\", providerUsed };\n    }\n    default: {\n      // Exhaustive safety: should never happen due to NodeType typing.\n      return input;\n    }\n  }\n}\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;AAAA;AAeO,IAAM,WAAW,KAAK;AAAA,EAC3B,IAAI;AAAA,EACJ,KAAK,8BACH,SAKA,EAAE,IAAI,MACH;AACH,WAAO,KAAK,wBAAwB;AAAA,MAClC,QAAQ,QAAQ;AAAA,MAChB,MAAM,QAAQ;AAAA,MACd,OAAO,IAAI,IAAI;AAAA,IACjB,CAAC;AAED,UAAM,MAAM,aAAa,IAAI,QAAQ,IAAI;AAGzC,UAAM,iBAAiB,IAAI,YAAY,MAAM,QAAQ,KAAK;AAG1D,UAAM,YAAqB,YAAY,QAAQ,MAAM,cAAc;AAGnE,UAAM,kBAAkB,IAAI,aAAa,MAAM,SAAS;AAExD,WAAO,KAAK,2BAA2B;AAAA,MACrC,QAAQ,QAAQ;AAAA,MAChB,MAAM,QAAQ;AAAA,MACd,QAAQ;AAAA,MACR,OAAO,IAAI,IAAI;AAAA,IACjB,CAAC;AAED,WAAO;AAAA,EACT,GAjCK;AAkCP,CAAC;AAED,SAAS,YAAY,MAAgB,OAAyB;AAC5D,UAAQ,MAAM;AAAA,IACZ,KAAK,UAAU;AAEb,aAAO,EAAE,MAAM,qBAAqB;AAAA,IACtC;AAAA,IACA,KAAK,SAAS;AAEZ,aAAO,EAAE,aAAa,qBAAqB,UAAU,YAAY;AAAA,IACnE;AAAA,IACA,KAAK,OAAO;AAEV,YAAM,SAAS,iBACZ,OAAO;AAAA,QACN,QAAQ,iBAAE,OAAO;AAAA,UACf,WAAW,iBAAE,MAAM,iBAAE,OAAO,CAAC;AAAA,QAC/B,CAAC;AAAA,MACH,CAAC,EACA,UAAU,KAAK;AAElB,YAAM,eAAe,OAAO,UAAU,OAAO,KAAK,OAAO,UAAU,CAAC,KAAK,SAAS;AAClF,aAAO,EAAE,MAAM,mBAAmB,aAAa;AAAA,IACjD;AAAA,IACA,SAAS;AAEP,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA5BS;",
  "names": []
}
