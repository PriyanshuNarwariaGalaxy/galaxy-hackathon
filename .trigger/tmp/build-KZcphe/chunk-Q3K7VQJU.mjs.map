{
  "version": 3,
  "sources": ["../../../src/trigger/tasks/llm.task.ts"],
  "sourcesContent": ["import { task } from \"@trigger.dev/sdk/v3\";\nimport { nodeRegistry } from \"@/src/core/nodes/registry\";\nimport { prisma } from \"@/src/db/prisma\";\nimport { submitFalJob, resumeFalJob } from \"@/src/trigger/providers/fal/adapter\";\nimport { falProviderId } from \"@/src/trigger/providers/fal/types\";\n\nfunction now() {\n  return new Date();\n}\n\n/**\n * LLM task:\n * - validates input/output with Zod contracts\n * - executes via provider fallback engine\n *\n * NOTE: Provider implementations are mocked (no real API calls yet).\n */\nexport const llmTask = task({\n  id: \"node.llm\",\n  run: async (payload: { workflowRunId: string; nodeId: string; input: unknown }) => {\n    const def = nodeRegistry.get(\"llm\");\n    const validatedInput = def.inputSchema.parse(payload.input);\n\n    await prisma.nodeRun.update({\n      where: { workflowRunId_nodeId: { workflowRunId: payload.workflowRunId, nodeId: payload.nodeId } },\n      data: { status: \"RUNNING\", startedAt: now(), input: validatedInput as any, provider: falProviderId },\n    });\n\n    // Submit job to fal and get a wait token (webhook URL is tokenUrl).\n    const submit = await submitFalJob({\n      workflowRunId: payload.workflowRunId,\n      nodeId: payload.nodeId,\n    });\n\n    await prisma.nodeRun.update({\n      where: { workflowRunId_nodeId: { workflowRunId: payload.workflowRunId, nodeId: payload.nodeId } },\n      data: {\n        status: \"WAITING\",\n        logs: [\n          {\n            event: \"submitted\",\n            provider: falProviderId,\n            tokenId: submit.tokenId,\n            tokenUrl: submit.tokenUrl,\n            at: new Date().toISOString(),\n          },\n        ] as any,\n      },\n    });\n\n    const resumed = await resumeFalJob({ tokenId: submit.tokenId });\n\n    // Ensure contract shape exactly matches output schema.\n    const validatedOutput = def.outputSchema.parse({\n      text: resumed.text,\n      providerUsed: falProviderId,\n    });\n\n    await prisma.nodeRun.update({\n      where: { workflowRunId_nodeId: { workflowRunId: payload.workflowRunId, nodeId: payload.nodeId } },\n      data: {\n        status: \"COMPLETED\",\n        finishedAt: now(),\n        output: validatedOutput as any,\n        provider: falProviderId,\n      },\n    });\n\n    return validatedOutput;\n  },\n});\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;AAAA;AAMA,SAAS,MAAM;AACb,SAAO,oBAAI,KAAK;AAClB;AAFS;AAWF,IAAM,UAAU,KAAK;AAAA,EAC1B,IAAI;AAAA,EACJ,KAAK,8BAAO,YAAuE;AACjF,UAAM,MAAM,aAAa,IAAI,KAAK;AAClC,UAAM,iBAAiB,IAAI,YAAY,MAAM,QAAQ,KAAK;AAE1D,UAAM,OAAO,QAAQ,OAAO;AAAA,MAC1B,OAAO,EAAE,sBAAsB,EAAE,eAAe,QAAQ,eAAe,QAAQ,QAAQ,OAAO,EAAE;AAAA,MAChG,MAAM,EAAE,QAAQ,WAAW,WAAW,IAAI,GAAG,OAAO,gBAAuB,UAAU,cAAc;AAAA,IACrG,CAAC;AAGD,UAAM,SAAS,MAAM,aAAa;AAAA,MAChC,eAAe,QAAQ;AAAA,MACvB,QAAQ,QAAQ;AAAA,IAClB,CAAC;AAED,UAAM,OAAO,QAAQ,OAAO;AAAA,MAC1B,OAAO,EAAE,sBAAsB,EAAE,eAAe,QAAQ,eAAe,QAAQ,QAAQ,OAAO,EAAE;AAAA,MAChG,MAAM;AAAA,QACJ,QAAQ;AAAA,QACR,MAAM;AAAA,UACJ;AAAA,YACE,OAAO;AAAA,YACP,UAAU;AAAA,YACV,SAAS,OAAO;AAAA,YAChB,UAAU,OAAO;AAAA,YACjB,KAAI,oBAAI,KAAK,GAAE,YAAY;AAAA,UAC7B;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAED,UAAM,UAAU,MAAM,aAAa,EAAE,SAAS,OAAO,QAAQ,CAAC;AAG9D,UAAM,kBAAkB,IAAI,aAAa,MAAM;AAAA,MAC7C,MAAM,QAAQ;AAAA,MACd,cAAc;AAAA,IAChB,CAAC;AAED,UAAM,OAAO,QAAQ,OAAO;AAAA,MAC1B,OAAO,EAAE,sBAAsB,EAAE,eAAe,QAAQ,eAAe,QAAQ,QAAQ,OAAO,EAAE;AAAA,MAChG,MAAM;AAAA,QACJ,QAAQ;AAAA,QACR,YAAY,IAAI;AAAA,QAChB,QAAQ;AAAA,QACR,UAAU;AAAA,MACZ;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT,GAlDK;AAmDP,CAAC;",
  "names": []
}
