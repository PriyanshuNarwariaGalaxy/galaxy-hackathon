{
  "version": 3,
  "sources": ["../../../src/core/workflow/workflow.schema.ts", "../../../src/core/workflow/dag.ts"],
  "sourcesContent": ["import { z } from \"zod\";\nimport { nodeTypeSchema } from \"../nodes/registry\";\n\n/**\n * Workflow schema represents the canvas state (not execution state).\n * - `input` is intentionally `unknown` here to match the UI/data layer.\n * - Contract validation of each node's `input` is performed via the NodeRegistry\n *   (because schemas live with node definitions).\n */\n\nexport const workflowNodeSchema = z.object({\n  id: z.string().min(1, \"Node id must be a non-empty string.\"),\n  type: nodeTypeSchema,\n  input: z.unknown(),\n});\n\nexport const workflowEdgeSchema = z.object({\n  from: z.string().min(1, \"Edge.from must be a non-empty string.\"),\n  to: z.string().min(1, \"Edge.to must be a non-empty string.\"),\n});\n\nexport const workflowSchema = z\n  .object({\n    nodes: z.array(workflowNodeSchema),\n    edges: z.array(workflowEdgeSchema),\n  })\n  .superRefine((workflow, ctx) => {\n    // Enforce unique node ids (critical for DAG correctness).\n    const ids = workflow.nodes.map((n) => n.id);\n    const duplicates = ids.filter((id, idx) => ids.indexOf(id) !== idx);\n    if (duplicates.length > 0) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: `Duplicate node ids are not allowed: ${Array.from(new Set(duplicates)).join(\", \")}`,\n        path: [\"nodes\"],\n      });\n    }\n\n    const idSet = new Set(ids);\n    // Ensure edges reference existing nodes (good early error message for the canvas).\n    for (let i = 0; i < workflow.edges.length; i++) {\n      const e = workflow.edges[i];\n      if (!idSet.has(e.from)) {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: `Edge.from references unknown node id \"${e.from}\".`,\n          path: [\"edges\", i, \"from\"],\n        });\n      }\n      if (!idSet.has(e.to)) {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: `Edge.to references unknown node id \"${e.to}\".`,\n          path: [\"edges\", i, \"to\"],\n        });\n      }\n    }\n  });\n\nexport type Workflow = z.infer<typeof workflowSchema>;\nexport type WorkflowNode = z.infer<typeof workflowNodeSchema>;\nexport type WorkflowEdge = z.infer<typeof workflowEdgeSchema>;\n\n\n", "import type { WorkflowEdge, WorkflowNode } from \"./workflow.schema\";\n\n/**\n * DAG utilities for workflow execution planning.\n *\n * IMPORTANT:\n * - This is NOT execution.\n * - It only computes a valid topological order (node ids) given nodes + edges.\n * - It detects cycles and throws meaningful errors.\n */\n\nexport class WorkflowDagError extends Error {\n  override name = \"WorkflowDagError\";\n}\n\nfunction buildAdjacency(\n  nodes: ReadonlyArray<WorkflowNode>,\n  edges: ReadonlyArray<WorkflowEdge>,\n) {\n  const idSet = new Set<string>();\n  for (const n of nodes) {\n    if (idSet.has(n.id)) {\n      throw new WorkflowDagError(`Duplicate node id \"${n.id}\" detected.`);\n    }\n    idSet.add(n.id);\n  }\n\n  const adjacency = new Map<string, Set<string>>();\n  const indegree = new Map<string, number>();\n\n  for (const n of nodes) {\n    adjacency.set(n.id, new Set());\n    indegree.set(n.id, 0);\n  }\n\n  for (const e of edges) {\n    if (!idSet.has(e.from)) {\n      throw new WorkflowDagError(`Edge.from references unknown node id \"${e.from}\".`);\n    }\n    if (!idSet.has(e.to)) {\n      throw new WorkflowDagError(`Edge.to references unknown node id \"${e.to}\".`);\n    }\n    if (e.from === e.to) {\n      throw new WorkflowDagError(`Self-referential edge detected at node \"${e.from}\" (cycle).`);\n    }\n\n    const neighbors = adjacency.get(e.from)!;\n    // Ignore duplicate edges to keep indegree correct.\n    if (!neighbors.has(e.to)) {\n      neighbors.add(e.to);\n      indegree.set(e.to, (indegree.get(e.to) ?? 0) + 1);\n    }\n  }\n\n  return { adjacency, indegree, idSet };\n}\n\nfunction findCyclePath(adjacency: Map<string, Set<string>>): string[] | null {\n  // Classic DFS with colors to extract one cycle path for debugging.\n  const WHITE = 0;\n  const GRAY = 1;\n  const BLACK = 2;\n\n  const color = new Map<string, number>();\n  const parent = new Map<string, string | null>();\n\n  for (const nodeId of adjacency.keys()) {\n    color.set(nodeId, WHITE);\n    parent.set(nodeId, null);\n  }\n\n  const stack: string[] = [];\n\n  const dfs = (u: string): string[] | null => {\n    color.set(u, GRAY);\n    stack.push(u);\n\n    for (const v of adjacency.get(u) ?? []) {\n      const vColor = color.get(v) ?? WHITE;\n      if (vColor === WHITE) {\n        parent.set(v, u);\n        const cycle = dfs(v);\n        if (cycle) return cycle;\n      } else if (vColor === GRAY) {\n        // Found back edge u -> v. Extract cycle from stack.\n        const idx = stack.lastIndexOf(v);\n        const cycle = stack.slice(idx);\n        cycle.push(v); // close the loop\n        return cycle;\n      }\n    }\n\n    stack.pop();\n    color.set(u, BLACK);\n    return null;\n  };\n\n  for (const nodeId of adjacency.keys()) {\n    if ((color.get(nodeId) ?? WHITE) === WHITE) {\n      const cycle = dfs(nodeId);\n      if (cycle) return cycle;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Returns node ids in a valid execution order (topological order).\n *\n * Throws:\n * - WorkflowDagError if an edge references unknown ids\n * - WorkflowDagError if there is a cycle\n */\nexport function topologicallySortNodeIds(\n  nodes: ReadonlyArray<WorkflowNode>,\n  edges: ReadonlyArray<WorkflowEdge>,\n): string[] {\n  const { adjacency, indegree } = buildAdjacency(nodes, edges);\n\n  // Kahn's algorithm.\n  const queue: string[] = [];\n  for (const [nodeId, deg] of indegree.entries()) {\n    if (deg === 0) queue.push(nodeId);\n  }\n\n  const order: string[] = [];\n\n  while (queue.length > 0) {\n    const u = queue.shift()!;\n    order.push(u);\n\n    for (const v of adjacency.get(u) ?? []) {\n      const nextDeg = (indegree.get(v) ?? 0) - 1;\n      indegree.set(v, nextDeg);\n      if (nextDeg === 0) queue.push(v);\n    }\n  }\n\n  if (order.length !== nodes.length) {\n    const cycle = findCyclePath(adjacency);\n    if (cycle) {\n      throw new WorkflowDagError(`Cycle detected in workflow DAG: ${cycle.join(\" -> \")}`);\n    }\n    throw new WorkflowDagError(\"Cycle detected in workflow DAG.\");\n  }\n\n  return order;\n}\n\n"],
  "mappings": "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",
  "names": []
}
